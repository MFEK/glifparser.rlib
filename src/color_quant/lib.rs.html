<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Source of the Rust file `/home/fred/.cargo/registry/src/github.com-1ecc6299db9ec823/color_quant-1.1.0/src/lib.rs`."><meta name="keywords" content="rust, rustlang, rust-lang"><title>lib.rs - source</title><link rel="preload" as="font" type="font/woff2" crossorigin href="../../SourceSerif4-Regular.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../FiraSans-Regular.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../FiraSans-Medium.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../SourceCodePro-Regular.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../SourceSerif4-Bold.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../SourceCodePro-Semibold.ttf.woff2"><link rel="stylesheet" href="../../normalize.css"><link rel="stylesheet" href="../../rustdoc.css" id="mainThemeStyle"><link rel="stylesheet" href="../../ayu.css" disabled><link rel="stylesheet" href="../../dark.css" disabled><link rel="stylesheet" href="../../light.css" id="themeStyle"><script id="default-settings" ></script><script src="../../storage.js"></script><script defer src="../../source-script.js"></script><script defer src="../../source-files.js"></script><script defer src="../../main.js"></script><noscript><link rel="stylesheet" href="../../noscript.css"></noscript><link rel="alternate icon" type="image/png" href="../../favicon-16x16.png"><link rel="alternate icon" type="image/png" href="../../favicon-32x32.png"><link rel="icon" type="image/svg+xml" href="../../favicon.svg"></head><body class="rustdoc source"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle">&#9776;</button><a class="sidebar-logo" href="../../color_quant/index.html"><div class="logo-container"><img class="rust-logo" src="../../rust-logo.svg" alt="logo"></div></a><h2 class="location"></h2></nav><nav class="sidebar"><a class="sidebar-logo" href="../../color_quant/index.html"><div class="logo-container"><img class="rust-logo" src="../../rust-logo.svg" alt="logo"></div></a></nav><main><div class="width-limiter"><div class="sub-container"><a class="sub-logo-container" href="../../color_quant/index.html"><img class="rust-logo" src="../../rust-logo.svg" alt="logo"></a><nav class="sub"><form class="search-form"><div class="search-container"><span></span><input class="search-input" name="search" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"><div id="help-button" title="help" tabindex="-1"><button type="button">?</button></div><div id="settings-menu" tabindex="-1"><a href="../../settings.html" title="settings"><img width="22" height="22" alt="Change settings" src="../../wheel.svg"></a></div></div></form></nav></div><section id="main-content" class="content"><div class="example-wrap"><pre class="line-numbers"><span id="1">1</span>
<span id="2">2</span>
<span id="3">3</span>
<span id="4">4</span>
<span id="5">5</span>
<span id="6">6</span>
<span id="7">7</span>
<span id="8">8</span>
<span id="9">9</span>
<span id="10">10</span>
<span id="11">11</span>
<span id="12">12</span>
<span id="13">13</span>
<span id="14">14</span>
<span id="15">15</span>
<span id="16">16</span>
<span id="17">17</span>
<span id="18">18</span>
<span id="19">19</span>
<span id="20">20</span>
<span id="21">21</span>
<span id="22">22</span>
<span id="23">23</span>
<span id="24">24</span>
<span id="25">25</span>
<span id="26">26</span>
<span id="27">27</span>
<span id="28">28</span>
<span id="29">29</span>
<span id="30">30</span>
<span id="31">31</span>
<span id="32">32</span>
<span id="33">33</span>
<span id="34">34</span>
<span id="35">35</span>
<span id="36">36</span>
<span id="37">37</span>
<span id="38">38</span>
<span id="39">39</span>
<span id="40">40</span>
<span id="41">41</span>
<span id="42">42</span>
<span id="43">43</span>
<span id="44">44</span>
<span id="45">45</span>
<span id="46">46</span>
<span id="47">47</span>
<span id="48">48</span>
<span id="49">49</span>
<span id="50">50</span>
<span id="51">51</span>
<span id="52">52</span>
<span id="53">53</span>
<span id="54">54</span>
<span id="55">55</span>
<span id="56">56</span>
<span id="57">57</span>
<span id="58">58</span>
<span id="59">59</span>
<span id="60">60</span>
<span id="61">61</span>
<span id="62">62</span>
<span id="63">63</span>
<span id="64">64</span>
<span id="65">65</span>
<span id="66">66</span>
<span id="67">67</span>
<span id="68">68</span>
<span id="69">69</span>
<span id="70">70</span>
<span id="71">71</span>
<span id="72">72</span>
<span id="73">73</span>
<span id="74">74</span>
<span id="75">75</span>
<span id="76">76</span>
<span id="77">77</span>
<span id="78">78</span>
<span id="79">79</span>
<span id="80">80</span>
<span id="81">81</span>
<span id="82">82</span>
<span id="83">83</span>
<span id="84">84</span>
<span id="85">85</span>
<span id="86">86</span>
<span id="87">87</span>
<span id="88">88</span>
<span id="89">89</span>
<span id="90">90</span>
<span id="91">91</span>
<span id="92">92</span>
<span id="93">93</span>
<span id="94">94</span>
<span id="95">95</span>
<span id="96">96</span>
<span id="97">97</span>
<span id="98">98</span>
<span id="99">99</span>
<span id="100">100</span>
<span id="101">101</span>
<span id="102">102</span>
<span id="103">103</span>
<span id="104">104</span>
<span id="105">105</span>
<span id="106">106</span>
<span id="107">107</span>
<span id="108">108</span>
<span id="109">109</span>
<span id="110">110</span>
<span id="111">111</span>
<span id="112">112</span>
<span id="113">113</span>
<span id="114">114</span>
<span id="115">115</span>
<span id="116">116</span>
<span id="117">117</span>
<span id="118">118</span>
<span id="119">119</span>
<span id="120">120</span>
<span id="121">121</span>
<span id="122">122</span>
<span id="123">123</span>
<span id="124">124</span>
<span id="125">125</span>
<span id="126">126</span>
<span id="127">127</span>
<span id="128">128</span>
<span id="129">129</span>
<span id="130">130</span>
<span id="131">131</span>
<span id="132">132</span>
<span id="133">133</span>
<span id="134">134</span>
<span id="135">135</span>
<span id="136">136</span>
<span id="137">137</span>
<span id="138">138</span>
<span id="139">139</span>
<span id="140">140</span>
<span id="141">141</span>
<span id="142">142</span>
<span id="143">143</span>
<span id="144">144</span>
<span id="145">145</span>
<span id="146">146</span>
<span id="147">147</span>
<span id="148">148</span>
<span id="149">149</span>
<span id="150">150</span>
<span id="151">151</span>
<span id="152">152</span>
<span id="153">153</span>
<span id="154">154</span>
<span id="155">155</span>
<span id="156">156</span>
<span id="157">157</span>
<span id="158">158</span>
<span id="159">159</span>
<span id="160">160</span>
<span id="161">161</span>
<span id="162">162</span>
<span id="163">163</span>
<span id="164">164</span>
<span id="165">165</span>
<span id="166">166</span>
<span id="167">167</span>
<span id="168">168</span>
<span id="169">169</span>
<span id="170">170</span>
<span id="171">171</span>
<span id="172">172</span>
<span id="173">173</span>
<span id="174">174</span>
<span id="175">175</span>
<span id="176">176</span>
<span id="177">177</span>
<span id="178">178</span>
<span id="179">179</span>
<span id="180">180</span>
<span id="181">181</span>
<span id="182">182</span>
<span id="183">183</span>
<span id="184">184</span>
<span id="185">185</span>
<span id="186">186</span>
<span id="187">187</span>
<span id="188">188</span>
<span id="189">189</span>
<span id="190">190</span>
<span id="191">191</span>
<span id="192">192</span>
<span id="193">193</span>
<span id="194">194</span>
<span id="195">195</span>
<span id="196">196</span>
<span id="197">197</span>
<span id="198">198</span>
<span id="199">199</span>
<span id="200">200</span>
<span id="201">201</span>
<span id="202">202</span>
<span id="203">203</span>
<span id="204">204</span>
<span id="205">205</span>
<span id="206">206</span>
<span id="207">207</span>
<span id="208">208</span>
<span id="209">209</span>
<span id="210">210</span>
<span id="211">211</span>
<span id="212">212</span>
<span id="213">213</span>
<span id="214">214</span>
<span id="215">215</span>
<span id="216">216</span>
<span id="217">217</span>
<span id="218">218</span>
<span id="219">219</span>
<span id="220">220</span>
<span id="221">221</span>
<span id="222">222</span>
<span id="223">223</span>
<span id="224">224</span>
<span id="225">225</span>
<span id="226">226</span>
<span id="227">227</span>
<span id="228">228</span>
<span id="229">229</span>
<span id="230">230</span>
<span id="231">231</span>
<span id="232">232</span>
<span id="233">233</span>
<span id="234">234</span>
<span id="235">235</span>
<span id="236">236</span>
<span id="237">237</span>
<span id="238">238</span>
<span id="239">239</span>
<span id="240">240</span>
<span id="241">241</span>
<span id="242">242</span>
<span id="243">243</span>
<span id="244">244</span>
<span id="245">245</span>
<span id="246">246</span>
<span id="247">247</span>
<span id="248">248</span>
<span id="249">249</span>
<span id="250">250</span>
<span id="251">251</span>
<span id="252">252</span>
<span id="253">253</span>
<span id="254">254</span>
<span id="255">255</span>
<span id="256">256</span>
<span id="257">257</span>
<span id="258">258</span>
<span id="259">259</span>
<span id="260">260</span>
<span id="261">261</span>
<span id="262">262</span>
<span id="263">263</span>
<span id="264">264</span>
<span id="265">265</span>
<span id="266">266</span>
<span id="267">267</span>
<span id="268">268</span>
<span id="269">269</span>
<span id="270">270</span>
<span id="271">271</span>
<span id="272">272</span>
<span id="273">273</span>
<span id="274">274</span>
<span id="275">275</span>
<span id="276">276</span>
<span id="277">277</span>
<span id="278">278</span>
<span id="279">279</span>
<span id="280">280</span>
<span id="281">281</span>
<span id="282">282</span>
<span id="283">283</span>
<span id="284">284</span>
<span id="285">285</span>
<span id="286">286</span>
<span id="287">287</span>
<span id="288">288</span>
<span id="289">289</span>
<span id="290">290</span>
<span id="291">291</span>
<span id="292">292</span>
<span id="293">293</span>
<span id="294">294</span>
<span id="295">295</span>
<span id="296">296</span>
<span id="297">297</span>
<span id="298">298</span>
<span id="299">299</span>
<span id="300">300</span>
<span id="301">301</span>
<span id="302">302</span>
<span id="303">303</span>
<span id="304">304</span>
<span id="305">305</span>
<span id="306">306</span>
<span id="307">307</span>
<span id="308">308</span>
<span id="309">309</span>
<span id="310">310</span>
<span id="311">311</span>
<span id="312">312</span>
<span id="313">313</span>
<span id="314">314</span>
<span id="315">315</span>
<span id="316">316</span>
<span id="317">317</span>
<span id="318">318</span>
<span id="319">319</span>
<span id="320">320</span>
<span id="321">321</span>
<span id="322">322</span>
<span id="323">323</span>
<span id="324">324</span>
<span id="325">325</span>
<span id="326">326</span>
<span id="327">327</span>
<span id="328">328</span>
<span id="329">329</span>
<span id="330">330</span>
<span id="331">331</span>
<span id="332">332</span>
<span id="333">333</span>
<span id="334">334</span>
<span id="335">335</span>
<span id="336">336</span>
<span id="337">337</span>
<span id="338">338</span>
<span id="339">339</span>
<span id="340">340</span>
<span id="341">341</span>
<span id="342">342</span>
<span id="343">343</span>
<span id="344">344</span>
<span id="345">345</span>
<span id="346">346</span>
<span id="347">347</span>
<span id="348">348</span>
<span id="349">349</span>
<span id="350">350</span>
<span id="351">351</span>
<span id="352">352</span>
<span id="353">353</span>
<span id="354">354</span>
<span id="355">355</span>
<span id="356">356</span>
<span id="357">357</span>
<span id="358">358</span>
<span id="359">359</span>
<span id="360">360</span>
<span id="361">361</span>
<span id="362">362</span>
<span id="363">363</span>
<span id="364">364</span>
<span id="365">365</span>
<span id="366">366</span>
<span id="367">367</span>
<span id="368">368</span>
<span id="369">369</span>
<span id="370">370</span>
<span id="371">371</span>
<span id="372">372</span>
<span id="373">373</span>
<span id="374">374</span>
<span id="375">375</span>
<span id="376">376</span>
<span id="377">377</span>
<span id="378">378</span>
<span id="379">379</span>
<span id="380">380</span>
<span id="381">381</span>
<span id="382">382</span>
<span id="383">383</span>
<span id="384">384</span>
<span id="385">385</span>
<span id="386">386</span>
<span id="387">387</span>
<span id="388">388</span>
<span id="389">389</span>
<span id="390">390</span>
<span id="391">391</span>
<span id="392">392</span>
<span id="393">393</span>
<span id="394">394</span>
<span id="395">395</span>
<span id="396">396</span>
<span id="397">397</span>
<span id="398">398</span>
<span id="399">399</span>
<span id="400">400</span>
<span id="401">401</span>
<span id="402">402</span>
<span id="403">403</span>
<span id="404">404</span>
<span id="405">405</span>
<span id="406">406</span>
<span id="407">407</span>
<span id="408">408</span>
<span id="409">409</span>
<span id="410">410</span>
<span id="411">411</span>
<span id="412">412</span>
<span id="413">413</span>
<span id="414">414</span>
<span id="415">415</span>
<span id="416">416</span>
<span id="417">417</span>
<span id="418">418</span>
<span id="419">419</span>
<span id="420">420</span>
<span id="421">421</span>
<span id="422">422</span>
<span id="423">423</span>
<span id="424">424</span>
<span id="425">425</span>
<span id="426">426</span>
<span id="427">427</span>
<span id="428">428</span>
<span id="429">429</span>
<span id="430">430</span>
<span id="431">431</span>
<span id="432">432</span>
<span id="433">433</span>
<span id="434">434</span>
<span id="435">435</span>
<span id="436">436</span>
<span id="437">437</span>
<span id="438">438</span>
<span id="439">439</span>
<span id="440">440</span>
<span id="441">441</span>
<span id="442">442</span>
<span id="443">443</span>
<span id="444">444</span>
<span id="445">445</span>
<span id="446">446</span>
<span id="447">447</span>
<span id="448">448</span>
<span id="449">449</span>
<span id="450">450</span>
<span id="451">451</span>
<span id="452">452</span>
<span id="453">453</span>
<span id="454">454</span>
<span id="455">455</span>
<span id="456">456</span>
<span id="457">457</span>
<span id="458">458</span>
<span id="459">459</span>
<span id="460">460</span>
<span id="461">461</span>
<span id="462">462</span>
<span id="463">463</span>
<span id="464">464</span>
<span id="465">465</span>
<span id="466">466</span>
<span id="467">467</span>
<span id="468">468</span>
<span id="469">469</span>
<span id="470">470</span>
<span id="471">471</span>
<span id="472">472</span>
<span id="473">473</span>
<span id="474">474</span>
<span id="475">475</span>
<span id="476">476</span>
<span id="477">477</span>
<span id="478">478</span>
<span id="479">479</span>
<span id="480">480</span>
</pre><pre class="rust"><code><span class="comment">/*
NeuQuant Neural-Net Quantization Algorithm by Anthony Dekker, 1994.
See &quot;Kohonen neural networks for optimal colour quantization&quot;
in &quot;Network: Computation in Neural Systems&quot; Vol. 5 (1994) pp 351-367.
for a discussion of the algorithm.
See also http://members.ozemail.com.au/~dekker/NEUQUANT.HTML

Incorporated bugfixes and alpha channel handling from pngnq
http://pngnq.sourceforge.net

Copyright (c) 2014 The Piston Developers

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the &quot;Software&quot;), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.

NeuQuant Neural-Net Quantization Algorithm
------------------------------------------

Copyright (c) 1994 Anthony Dekker

NEUQUANT Neural-Net quantization algorithm by Anthony Dekker, 1994.
See &quot;Kohonen neural networks for optimal colour quantization&quot;
in &quot;Network: Computation in Neural Systems&quot; Vol. 5 (1994) pp 351-367.
for a discussion of the algorithm.
See also  http://members.ozemail.com.au/~dekker/NEUQUANT.HTML

Any party obtaining a copy of these files from the author, directly or
indirectly, is granted, free of charge, a full and unrestricted irrevocable,
world-wide, paid up, royalty-free, nonexclusive right and license to deal
in this software and documentation files (the &quot;Software&quot;), including without
limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,
and/or sell copies of the Software, and to permit persons who receive
copies from any such party to do so, with the only requirement being
that this copyright notice remain intact.

*/

</span><span class="doccomment">//! # Color quantization library
//!
//! This library provides a color quantizer based on the [NEUQUANT](http://members.ozemail.com.au/~dekker/NEUQUANT.HTML)
//!
//! Original literature: Dekker, A. H. (1994). Kohonen neural networks for
//! optimal colour quantization. *Network: Computation in Neural Systems*, 5(3), 351-367.
//! [doi: 10.1088/0954-898X_5_3_003](https://doi.org/10.1088/0954-898X_5_3_003)
//!
//! See also &lt;https://scientificgems.wordpress.com/stuff/neuquant-fast-high-quality-image-quantization/&gt;
//!
//! ## Usage
//!
//! ```
//! let data = vec![0; 40];
//! let nq = color_quant::NeuQuant::new(10, 256, &amp;data);
//! let indixes: Vec&lt;u8&gt; = data.chunks(4).map(|pix| nq.index_of(pix) as u8).collect();
//! let color_map = nq.color_map_rgba();
//! ```

</span><span class="kw">mod </span>math;
<span class="kw">use </span><span class="kw">crate</span>::math::clamp;

<span class="kw">use </span>std::cmp::{max, min};

<span class="kw">const </span>CHANNELS: usize = <span class="number">4</span>;

<span class="kw">const </span>RADIUS_DEC: i32 = <span class="number">30</span>; <span class="comment">// factor of 1/30 each cycle

</span><span class="kw">const </span>ALPHA_BIASSHIFT: i32 = <span class="number">10</span>; <span class="comment">// alpha starts at 1
</span><span class="kw">const </span>INIT_ALPHA: i32 = <span class="number">1 </span>&lt;&lt; ALPHA_BIASSHIFT; <span class="comment">// biased by 10 bits

</span><span class="kw">const </span>GAMMA: f64 = <span class="number">1024.0</span>;
<span class="kw">const </span>BETA: f64 = <span class="number">1.0 </span>/ GAMMA;
<span class="kw">const </span>BETAGAMMA: f64 = BETA * GAMMA;

<span class="comment">// four primes near 500 - assume no image has a length so large
// that it is divisible by all four primes
</span><span class="kw">const </span>PRIMES: [usize; <span class="number">4</span>] = [<span class="number">499</span>, <span class="number">491</span>, <span class="number">478</span>, <span class="number">503</span>];

<span class="attribute">#[derive(Clone, Copy)]
</span><span class="kw">struct </span>Quad&lt;T&gt; {
    r: T,
    g: T,
    b: T,
    a: T,
}

<span class="kw">type </span>Neuron = Quad&lt;f64&gt;;
<span class="kw">type </span>Color = Quad&lt;i32&gt;;

<span class="kw">pub struct </span>NeuQuant {
    network: Vec&lt;Neuron&gt;,
    colormap: Vec&lt;Color&gt;,
    netindex: Vec&lt;usize&gt;,
    bias: Vec&lt;f64&gt;, <span class="comment">// bias and freq arrays for learning
    </span>freq: Vec&lt;f64&gt;,
    samplefac: i32,
    netsize: usize,
}

<span class="kw">impl </span>NeuQuant {
    <span class="doccomment">/// Creates a new neuronal network and trains it with the supplied data.
    ///
    /// Pixels are assumed to be in RGBA format.
    /// `colors` should be $&gt;=64$. `samplefac` determines the faction of
    /// the sample that will be used to train the network. Its value must be in the
    /// range $[1, 30]$. A value of $1$ thus produces the best result but is also
    /// slowest. $10$ is a good compromise between speed and quality.
    </span><span class="kw">pub fn </span>new(samplefac: i32, colors: usize, pixels: <span class="kw-2">&amp;</span>[u8]) -&gt; <span class="self">Self </span>{
        <span class="kw">let </span>netsize = colors;
        <span class="kw">let </span><span class="kw-2">mut </span>this = NeuQuant {
            network: Vec::with_capacity(netsize),
            colormap: Vec::with_capacity(netsize),
            netindex: <span class="macro">vec!</span>[<span class="number">0</span>; <span class="number">256</span>],
            bias: Vec::with_capacity(netsize),
            freq: Vec::with_capacity(netsize),
            samplefac: samplefac,
            netsize: colors,
        };
        this.init(pixels);
        this
    }

    <span class="doccomment">/// Initializes the neuronal network and trains it with the supplied data.
    ///
    /// This method gets called by `Self::new`.
    </span><span class="kw">pub fn </span>init(<span class="kw-2">&amp;mut </span><span class="self">self</span>, pixels: <span class="kw-2">&amp;</span>[u8]) {
        <span class="self">self</span>.network.clear();
        <span class="self">self</span>.colormap.clear();
        <span class="self">self</span>.bias.clear();
        <span class="self">self</span>.freq.clear();
        <span class="kw">let </span>freq = (<span class="self">self</span>.netsize <span class="kw">as </span>f64).recip();
        <span class="kw">for </span>i <span class="kw">in </span><span class="number">0</span>..<span class="self">self</span>.netsize {
            <span class="kw">let </span>tmp = (i <span class="kw">as </span>f64) * <span class="number">256.0 </span>/ (<span class="self">self</span>.netsize <span class="kw">as </span>f64);
            <span class="comment">// Sets alpha values at 0 for dark pixels.
            </span><span class="kw">let </span>a = <span class="kw">if </span>i &lt; <span class="number">16 </span>{ i <span class="kw">as </span>f64 * <span class="number">16.0 </span>} <span class="kw">else </span>{ <span class="number">255.0 </span>};
            <span class="self">self</span>.network.push(Neuron {
                r: tmp,
                g: tmp,
                b: tmp,
                a: a,
            });
            <span class="self">self</span>.colormap.push(Color {
                r: <span class="number">0</span>,
                g: <span class="number">0</span>,
                b: <span class="number">0</span>,
                a: <span class="number">255</span>,
            });
            <span class="self">self</span>.freq.push(freq);
            <span class="self">self</span>.bias.push(<span class="number">0.0</span>);
        }
        <span class="self">self</span>.learn(pixels);
        <span class="self">self</span>.build_colormap();
        <span class="self">self</span>.build_netindex();
    }

    <span class="doccomment">/// Maps the rgba-pixel in-place to the best-matching color in the color map.
    </span><span class="attribute">#[inline(always)]
    </span><span class="kw">pub fn </span>map_pixel(<span class="kw-2">&amp;</span><span class="self">self</span>, pixel: <span class="kw-2">&amp;mut </span>[u8]) {
        <span class="macro">assert!</span>(pixel.len() == <span class="number">4</span>);
        <span class="kw">let </span>(r, g, b, a) = (pixel[<span class="number">0</span>], pixel[<span class="number">1</span>], pixel[<span class="number">2</span>], pixel[<span class="number">3</span>]);
        <span class="kw">let </span>i = <span class="self">self</span>.search_netindex(b, g, r, a);
        pixel[<span class="number">0</span>] = <span class="self">self</span>.colormap[i].r <span class="kw">as </span>u8;
        pixel[<span class="number">1</span>] = <span class="self">self</span>.colormap[i].g <span class="kw">as </span>u8;
        pixel[<span class="number">2</span>] = <span class="self">self</span>.colormap[i].b <span class="kw">as </span>u8;
        pixel[<span class="number">3</span>] = <span class="self">self</span>.colormap[i].a <span class="kw">as </span>u8;
    }

    <span class="doccomment">/// Finds the best-matching index in the color map.
    ///
    /// `pixel` is assumed to be in RGBA format.
    </span><span class="attribute">#[inline(always)]
    </span><span class="kw">pub fn </span>index_of(<span class="kw-2">&amp;</span><span class="self">self</span>, pixel: <span class="kw-2">&amp;</span>[u8]) -&gt; usize {
        <span class="macro">assert!</span>(pixel.len() == <span class="number">4</span>);
        <span class="kw">let </span>(r, g, b, a) = (pixel[<span class="number">0</span>], pixel[<span class="number">1</span>], pixel[<span class="number">2</span>], pixel[<span class="number">3</span>]);
        <span class="self">self</span>.search_netindex(b, g, r, a)
    }

    <span class="doccomment">/// Lookup pixel values for color at `idx` in the colormap.
    </span><span class="kw">pub fn </span>lookup(<span class="kw-2">&amp;</span><span class="self">self</span>, idx: usize) -&gt; <span class="prelude-ty">Option</span>&lt;[u8; <span class="number">4</span>]&gt; {
        <span class="self">self</span>.colormap
            .get(idx)
            .map(|p| [p.r <span class="kw">as </span>u8, p.g <span class="kw">as </span>u8, p.b <span class="kw">as </span>u8, p.a <span class="kw">as </span>u8])
    }

    <span class="doccomment">/// Returns the RGBA color map calculated from the sample.
    </span><span class="kw">pub fn </span>color_map_rgba(<span class="kw-2">&amp;</span><span class="self">self</span>) -&gt; Vec&lt;u8&gt; {
        <span class="kw">let </span><span class="kw-2">mut </span>map = Vec::with_capacity(<span class="self">self</span>.netsize * <span class="number">4</span>);
        <span class="kw">for </span>entry <span class="kw">in </span><span class="kw-2">&amp;</span><span class="self">self</span>.colormap {
            map.push(entry.r <span class="kw">as </span>u8);
            map.push(entry.g <span class="kw">as </span>u8);
            map.push(entry.b <span class="kw">as </span>u8);
            map.push(entry.a <span class="kw">as </span>u8);
        }
        map
    }

    <span class="doccomment">/// Returns the RGBA color map calculated from the sample.
    </span><span class="kw">pub fn </span>color_map_rgb(<span class="kw-2">&amp;</span><span class="self">self</span>) -&gt; Vec&lt;u8&gt; {
        <span class="kw">let </span><span class="kw-2">mut </span>map = Vec::with_capacity(<span class="self">self</span>.netsize * <span class="number">3</span>);
        <span class="kw">for </span>entry <span class="kw">in </span><span class="kw-2">&amp;</span><span class="self">self</span>.colormap {
            map.push(entry.r <span class="kw">as </span>u8);
            map.push(entry.g <span class="kw">as </span>u8);
            map.push(entry.b <span class="kw">as </span>u8);
        }
        map
    }

    <span class="doccomment">/// Move neuron i towards biased (a,b,g,r) by factor alpha
    </span><span class="kw">fn </span>salter_single(<span class="kw-2">&amp;mut </span><span class="self">self</span>, alpha: f64, i: i32, quad: Quad&lt;f64&gt;) {
        <span class="kw">let </span>n = <span class="kw-2">&amp;mut </span><span class="self">self</span>.network[i <span class="kw">as </span>usize];
        n.b -= alpha * (n.b - quad.b);
        n.g -= alpha * (n.g - quad.g);
        n.r -= alpha * (n.r - quad.r);
        n.a -= alpha * (n.a - quad.a);
    }

    <span class="doccomment">/// Move neuron adjacent neurons towards biased (a,b,g,r) by factor alpha
    </span><span class="kw">fn </span>alter_neighbour(<span class="kw-2">&amp;mut </span><span class="self">self</span>, alpha: f64, rad: i32, i: i32, quad: Quad&lt;f64&gt;) {
        <span class="kw">let </span>lo = max(i - rad, <span class="number">0</span>);
        <span class="kw">let </span>hi = min(i + rad, <span class="self">self</span>.netsize <span class="kw">as </span>i32);
        <span class="kw">let </span><span class="kw-2">mut </span>j = i + <span class="number">1</span>;
        <span class="kw">let </span><span class="kw-2">mut </span>k = i - <span class="number">1</span>;
        <span class="kw">let </span><span class="kw-2">mut </span>q = <span class="number">0</span>;

        <span class="kw">while </span>(j &lt; hi) || (k &gt; lo) {
            <span class="kw">let </span>rad_sq = rad <span class="kw">as </span>f64 * rad <span class="kw">as </span>f64;
            <span class="kw">let </span>alpha = (alpha * (rad_sq - q <span class="kw">as </span>f64 * q <span class="kw">as </span>f64)) / rad_sq;
            q += <span class="number">1</span>;
            <span class="kw">if </span>j &lt; hi {
                <span class="kw">let </span>p = <span class="kw-2">&amp;mut </span><span class="self">self</span>.network[j <span class="kw">as </span>usize];
                p.b -= alpha * (p.b - quad.b);
                p.g -= alpha * (p.g - quad.g);
                p.r -= alpha * (p.r - quad.r);
                p.a -= alpha * (p.a - quad.a);
                j += <span class="number">1</span>;
            }
            <span class="kw">if </span>k &gt; lo {
                <span class="kw">let </span>p = <span class="kw-2">&amp;mut </span><span class="self">self</span>.network[k <span class="kw">as </span>usize];
                p.b -= alpha * (p.b - quad.b);
                p.g -= alpha * (p.g - quad.g);
                p.r -= alpha * (p.r - quad.r);
                p.a -= alpha * (p.a - quad.a);
                k -= <span class="number">1</span>;
            }
        }
    }

    <span class="doccomment">/// Search for biased BGR values
    /// finds closest neuron (min dist) and updates freq
    /// finds best neuron (min dist-bias) and returns position
    /// for frequently chosen neurons, freq[i] is high and bias[i] is negative
    /// bias[i] = gamma*((1/self.netsize)-freq[i])
    </span><span class="kw">fn </span>contest(<span class="kw-2">&amp;mut </span><span class="self">self</span>, b: f64, g: f64, r: f64, a: f64) -&gt; i32 {
        <span class="kw">use </span>std::f64;

        <span class="kw">let </span><span class="kw-2">mut </span>bestd = f64::MAX;
        <span class="kw">let </span><span class="kw-2">mut </span>bestbiasd: f64 = bestd;
        <span class="kw">let </span><span class="kw-2">mut </span>bestpos = -<span class="number">1</span>;
        <span class="kw">let </span><span class="kw-2">mut </span>bestbiaspos: i32 = bestpos;

        <span class="kw">for </span>i <span class="kw">in </span><span class="number">0</span>..<span class="self">self</span>.netsize {
            <span class="kw">let </span>bestbiasd_biased = bestbiasd + <span class="self">self</span>.bias[i];
            <span class="kw">let </span><span class="kw-2">mut </span>dist;
            <span class="kw">let </span>n = <span class="kw-2">&amp;</span><span class="self">self</span>.network[i];
            dist = (n.b - b).abs();
            dist += (n.r - r).abs();
            <span class="kw">if </span>dist &lt; bestd || dist &lt; bestbiasd_biased {
                dist += (n.g - g).abs();
                dist += (n.a - a).abs();
                <span class="kw">if </span>dist &lt; bestd {
                    bestd = dist;
                    bestpos = i <span class="kw">as </span>i32;
                }
                <span class="kw">let </span>biasdist = dist - <span class="self">self</span>.bias[i];
                <span class="kw">if </span>biasdist &lt; bestbiasd {
                    bestbiasd = biasdist;
                    bestbiaspos = i <span class="kw">as </span>i32;
                }
            }
            <span class="self">self</span>.freq[i] -= BETA * <span class="self">self</span>.freq[i];
            <span class="self">self</span>.bias[i] += BETAGAMMA * <span class="self">self</span>.freq[i];
        }
        <span class="self">self</span>.freq[bestpos <span class="kw">as </span>usize] += BETA;
        <span class="self">self</span>.bias[bestpos <span class="kw">as </span>usize] -= BETAGAMMA;
        <span class="kw">return </span>bestbiaspos;
    }

    <span class="doccomment">/// Main learning loop
    /// Note: the number of learning cycles is crucial and the parameters are not
    /// optimized for net sizes &lt; 26 or &gt; 256. 1064 colors seems to work fine
    </span><span class="kw">fn </span>learn(<span class="kw-2">&amp;mut </span><span class="self">self</span>, pixels: <span class="kw-2">&amp;</span>[u8]) {
        <span class="kw">let </span>initrad: i32 = <span class="self">self</span>.netsize <span class="kw">as </span>i32 / <span class="number">8</span>; <span class="comment">// for 256 cols, radius starts at 32
        </span><span class="kw">let </span>radiusbiasshift: i32 = <span class="number">6</span>;
        <span class="kw">let </span>radiusbias: i32 = <span class="number">1 </span>&lt;&lt; radiusbiasshift;
        <span class="kw">let </span>init_bias_radius: i32 = initrad * radiusbias;
        <span class="kw">let </span><span class="kw-2">mut </span>bias_radius = init_bias_radius;
        <span class="kw">let </span>alphadec = <span class="number">30 </span>+ ((<span class="self">self</span>.samplefac - <span class="number">1</span>) / <span class="number">3</span>);
        <span class="kw">let </span>lengthcount = pixels.len() / CHANNELS;
        <span class="kw">let </span>samplepixels = lengthcount / <span class="self">self</span>.samplefac <span class="kw">as </span>usize;
        <span class="comment">// learning cycles
        </span><span class="kw">let </span>n_cycles = <span class="kw">match </span><span class="self">self</span>.netsize &gt;&gt; <span class="number">1 </span>{
            n <span class="kw">if </span>n &lt;= <span class="number">100 </span>=&gt; <span class="number">100</span>,
            n =&gt; n,
        };
        <span class="kw">let </span>delta = <span class="kw">match </span>samplepixels / n_cycles {
            <span class="number">0 </span>=&gt; <span class="number">1</span>,
            n =&gt; n,
        };
        <span class="kw">let </span><span class="kw-2">mut </span>alpha = INIT_ALPHA;

        <span class="kw">let </span><span class="kw-2">mut </span>rad = bias_radius &gt;&gt; radiusbiasshift;
        <span class="kw">if </span>rad &lt;= <span class="number">1 </span>{
            rad = <span class="number">0
        </span>};

        <span class="kw">let </span><span class="kw-2">mut </span>pos = <span class="number">0</span>;
        <span class="kw">let </span>step = <span class="kw-2">*</span>PRIMES
            .iter()
            .find(|&amp;&amp;prime| lengthcount % prime != <span class="number">0</span>)
            .unwrap_or(<span class="kw-2">&amp;</span>PRIMES[<span class="number">3</span>]);

        <span class="kw">let </span><span class="kw-2">mut </span>i = <span class="number">0</span>;
        <span class="kw">while </span>i &lt; samplepixels {
            <span class="kw">let </span>(r, g, b, a) = {
                <span class="kw">let </span>p = <span class="kw-2">&amp;</span>pixels[CHANNELS * pos..][..CHANNELS];
                (p[<span class="number">0</span>] <span class="kw">as </span>f64, p[<span class="number">1</span>] <span class="kw">as </span>f64, p[<span class="number">2</span>] <span class="kw">as </span>f64, p[<span class="number">3</span>] <span class="kw">as </span>f64)
            };

            <span class="kw">let </span>j = <span class="self">self</span>.contest(b, g, r, a);

            <span class="kw">let </span>alpha_ = (<span class="number">1.0 </span>* alpha <span class="kw">as </span>f64) / INIT_ALPHA <span class="kw">as </span>f64;
            <span class="self">self</span>.salter_single(alpha_, j, Quad { b, g, r, a });
            <span class="kw">if </span>rad &gt; <span class="number">0 </span>{
                <span class="self">self</span>.alter_neighbour(alpha_, rad, j, Quad { b, g, r, a })
            };

            pos += step;
            <span class="kw">while </span>pos &gt;= lengthcount {
                pos -= lengthcount
            }

            i += <span class="number">1</span>;
            <span class="kw">if </span>i % delta == <span class="number">0 </span>{
                alpha -= alpha / alphadec;
                bias_radius -= bias_radius / RADIUS_DEC;
                rad = bias_radius &gt;&gt; radiusbiasshift;
                <span class="kw">if </span>rad &lt;= <span class="number">1 </span>{
                    rad = <span class="number">0
                </span>};
            }
        }
    }

    <span class="doccomment">/// initializes the color map
    </span><span class="kw">fn </span>build_colormap(<span class="kw-2">&amp;mut </span><span class="self">self</span>) {
        <span class="kw">for </span>i <span class="kw">in </span><span class="number">0usize</span>..<span class="self">self</span>.netsize {
            <span class="self">self</span>.colormap[i].b = clamp(<span class="self">self</span>.network[i].b.round() <span class="kw">as </span>i32);
            <span class="self">self</span>.colormap[i].g = clamp(<span class="self">self</span>.network[i].g.round() <span class="kw">as </span>i32);
            <span class="self">self</span>.colormap[i].r = clamp(<span class="self">self</span>.network[i].r.round() <span class="kw">as </span>i32);
            <span class="self">self</span>.colormap[i].a = clamp(<span class="self">self</span>.network[i].a.round() <span class="kw">as </span>i32);
        }
    }

    <span class="doccomment">/// Insertion sort of network and building of netindex[0..255]
    </span><span class="kw">fn </span>build_netindex(<span class="kw-2">&amp;mut </span><span class="self">self</span>) {
        <span class="kw">let </span><span class="kw-2">mut </span>previouscol = <span class="number">0</span>;
        <span class="kw">let </span><span class="kw-2">mut </span>startpos = <span class="number">0</span>;

        <span class="kw">for </span>i <span class="kw">in </span><span class="number">0</span>..<span class="self">self</span>.netsize {
            <span class="kw">let </span><span class="kw-2">mut </span>p = <span class="self">self</span>.colormap[i];
            <span class="kw">let </span><span class="kw-2">mut </span>q;
            <span class="kw">let </span><span class="kw-2">mut </span>smallpos = i;
            <span class="kw">let </span><span class="kw-2">mut </span>smallval = p.g <span class="kw">as </span>usize; <span class="comment">// index on g
                                             // find smallest in i..netsize-1
            </span><span class="kw">for </span>j <span class="kw">in </span>(i + <span class="number">1</span>)..<span class="self">self</span>.netsize {
                q = <span class="self">self</span>.colormap[j];
                <span class="kw">if </span>(q.g <span class="kw">as </span>usize) &lt; smallval {
                    <span class="comment">// index on g
                    </span>smallpos = j;
                    smallval = q.g <span class="kw">as </span>usize; <span class="comment">// index on g
                </span>}
            }
            q = <span class="self">self</span>.colormap[smallpos];
            <span class="comment">// swap p (i) and q (smallpos) entries
            </span><span class="kw">if </span>i != smallpos {
                ::std::mem::swap(<span class="kw-2">&amp;mut </span>p, <span class="kw-2">&amp;mut </span>q);
                <span class="self">self</span>.colormap[i] = p;
                <span class="self">self</span>.colormap[smallpos] = q;
            }
            <span class="comment">// smallval entry is now in position i
            </span><span class="kw">if </span>smallval != previouscol {
                <span class="self">self</span>.netindex[previouscol] = (startpos + i) &gt;&gt; <span class="number">1</span>;
                <span class="kw">for </span>j <span class="kw">in </span>(previouscol + <span class="number">1</span>)..smallval {
                    <span class="self">self</span>.netindex[j] = i
                }
                previouscol = smallval;
                startpos = i;
            }
        }
        <span class="kw">let </span>max_netpos = <span class="self">self</span>.netsize - <span class="number">1</span>;
        <span class="self">self</span>.netindex[previouscol] = (startpos + max_netpos) &gt;&gt; <span class="number">1</span>;
        <span class="kw">for </span>j <span class="kw">in </span>(previouscol + <span class="number">1</span>)..<span class="number">256 </span>{
            <span class="self">self</span>.netindex[j] = max_netpos
        } <span class="comment">// really 256
    </span>}

    <span class="doccomment">/// Search for best matching color
    </span><span class="kw">fn </span>search_netindex(<span class="kw-2">&amp;</span><span class="self">self</span>, b: u8, g: u8, r: u8, a: u8) -&gt; usize {
        <span class="kw">let </span><span class="kw-2">mut </span>bestd = <span class="number">1 </span>&lt;&lt; <span class="number">30</span>; <span class="comment">// ~ 1_000_000
        </span><span class="kw">let </span><span class="kw-2">mut </span>best = <span class="number">0</span>;
        <span class="comment">// start at netindex[g] and work outwards
        </span><span class="kw">let </span><span class="kw-2">mut </span>i = <span class="self">self</span>.netindex[g <span class="kw">as </span>usize];
        <span class="kw">let </span><span class="kw-2">mut </span>j = <span class="kw">if </span>i &gt; <span class="number">0 </span>{ i - <span class="number">1 </span>} <span class="kw">else </span>{ <span class="number">0 </span>};

        <span class="kw">while </span>(i &lt; <span class="self">self</span>.netsize) || (j &gt; <span class="number">0</span>) {
            <span class="kw">if </span>i &lt; <span class="self">self</span>.netsize {
                <span class="kw">let </span>p = <span class="self">self</span>.colormap[i];
                <span class="kw">let </span><span class="kw-2">mut </span>e = p.g - g <span class="kw">as </span>i32;
                <span class="kw">let </span><span class="kw-2">mut </span>dist = e * e; <span class="comment">// inx key
                </span><span class="kw">if </span>dist &gt;= bestd {
                    <span class="kw">break</span>;
                } <span class="kw">else </span>{
                    e = p.b - b <span class="kw">as </span>i32;
                    dist += e * e;
                    <span class="kw">if </span>dist &lt; bestd {
                        e = p.r - r <span class="kw">as </span>i32;
                        dist += e * e;
                        <span class="kw">if </span>dist &lt; bestd {
                            e = p.a - a <span class="kw">as </span>i32;
                            dist += e * e;
                            <span class="kw">if </span>dist &lt; bestd {
                                bestd = dist;
                                best = i;
                            }
                        }
                    }
                    i += <span class="number">1</span>;
                }
            }
            <span class="kw">if </span>j &gt; <span class="number">0 </span>{
                <span class="kw">let </span>p = <span class="self">self</span>.colormap[j];
                <span class="kw">let </span><span class="kw-2">mut </span>e = p.g - g <span class="kw">as </span>i32;
                <span class="kw">let </span><span class="kw-2">mut </span>dist = e * e; <span class="comment">// inx key
                </span><span class="kw">if </span>dist &gt;= bestd {
                    <span class="kw">break</span>;
                } <span class="kw">else </span>{
                    e = p.b - b <span class="kw">as </span>i32;
                    dist += e * e;
                    <span class="kw">if </span>dist &lt; bestd {
                        e = p.r - r <span class="kw">as </span>i32;
                        dist += e * e;
                        <span class="kw">if </span>dist &lt; bestd {
                            e = p.a - a <span class="kw">as </span>i32;
                            dist += e * e;
                            <span class="kw">if </span>dist &lt; bestd {
                                bestd = dist;
                                best = j;
                            }
                        }
                    }
                    j -= <span class="number">1</span>;
                }
            }
        }
        best
    }
}
</code></pre></div>
</section></div></main><div id="rustdoc-vars" data-root-path="../../" data-current-crate="color_quant" data-themes="ayu,dark,light" data-resource-suffix="" data-rustdoc-version="1.65.0 (897e37553 2022-11-02)" ></div></body></html>